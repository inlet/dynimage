/* *	DynImage for ActionScript 3.0 *	Copyright Â© 2010 Inlet.nl *	All rights reserved. *	 *	http://github.com/inlet/dynimage *	 *	Redistribution and use in source and binary forms, with or without *	modification, are permitted provided that the following conditions are met: *	 *	- Redistributions of source code must retain the above copyright notice, *	this list of conditions and the following disclaimer. *	 *	- Redistributions in binary form must reproduce the above copyright notice, *	this list of conditions and the following disclaimer in the documentation *	and/or other materials provided with the distribution. *	 *	- Neither the name of the Log Meister nor the names of its contributors *	may be used to endorse or promote products derived from this software *	without specific prior written permission. *	 *	 *	DynImage is free software: you can redistribute it and/or modify *	it under the terms of the GNU Lesser General Public License as published by *	the Free Software Foundation, either version 3 of the License, or *	(at your option) any later version. *	 *	DynImage is distributed in the hope that it will be useful, *	but WITHOUT ANY WARRANTY; without even the implied warranty of *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *	GNU Lesser General Public License for more details. *	 *	You should have received a copy of the GNU Lesser General Public License *	along with DynImage.  If not, see <http://www.gnu.org/licenses/>. *	 *	Version 1.0 *	 */package dynimage {	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	internal class AbstractAsset extends Sprite 	{		/**		 * Loading state		 */		public var loadingStatus : String;		public var url : String;				protected var _preloader : DisplayObject;		protected var _asset : DisplayObject;		private var _autoStart : Boolean;		/**		 * Abstract asset.		 * 		 * @param url:String path to image		 * @param preloader:DisplayObject show a preloader while image is loading?		 * @param autoStart:Boolean (optional) directly start with loading?		 */		public function AbstractAsset(url : String, preloaderAsset : DisplayObject, autoStart : Boolean = true) 		{			this.url = url;			_preloader = preloaderAsset;			_autoStart = autoStart;						if (_preloader) placePreloader();			addEventListener(Event.REMOVED_FROM_STAGE, dispose);							if (autoStart) 			{				load();			}		}		/**		 * Load. Animate the preloader in.		 * Send onComplete function when preloader animation is finished.		 */		public function load() : void 		{			(_preloader) ? animatePreloaderIn(_preloader, animatePreloaderInCompleted) : animatePreloaderInCompleted(); 		}		protected function placePreloader() : void 		{			_preloader.visible = false;			_preloader.alpha = 0;			addChild(_preloader);		}		/**		 * Adds the image to loading queue.		 */		private function loadAsset() : void 		{			if (loadingStatus) return;			ImageQueue.addEventListener(ImageLoaderEvent.COMPLETE, handleAssetLoaderEvents);			ImageQueue.addEventListener(ImageLoaderEvent.PROGRESS, handleAssetLoaderEvents);			ImageQueue.addEventListener(ImageLoaderEvent.ERROR, handleAssetLoaderEvents);			ImageQueue.addEventListener(ImageLoaderEvent.START, handleAssetLoaderEvents);			ImageQueue.loadImage(url, this.name);		}		/**		 * Handle queue events for this image.		 * @param event:ImageLoaderEvent		 */		private function handleAssetLoaderEvents(event : ImageLoaderEvent) : void 		{			if (event.name != this.name) return;						var evt : ImageEvent;			switch (event.type) 			{				case ImageLoaderEvent.START:					evt = new ImageEvent(ImageEvent.STARTED);					break;				case ImageLoaderEvent.PROGRESS:					evt = new ImageEvent(ImageEvent.PROGRESS);					evt.bytesLoaded = event.loadedBytesCount;					evt.bytesTotal = event.totalBytesCount;					break;				case ImageLoaderEvent.ERROR:					evt = new ImageEvent(ImageEvent.ERROR);					evt.errorMessage = event.error;					break;			}						loadingStatus = event.type;			if (evt) dispatchEvent(evt);			if (event.type == ImageLoaderEvent.COMPLETE)			{				assetLoaded(event.asset);			}		}		/**		 * Image is completely loaded.		 * Add it on stage and send complete event.		 * 		 * @param asset:DisplayObject		 */		private function assetLoaded(asset : DisplayObject) : void 		{			_asset = getModifiedAsset(asset);			_asset.visible = false;			_asset.alpha = 0;			addChild(_asset);						(_preloader) ? animatePreloaderOut(_preloader, animatePreloaderOutCompleted) : animatePreloaderOutCompleted();			dispatchEvent(new ImageEvent(ImageEvent.COMPLETE));		}		/**		 * Override this one to apply a specified modifier.		 * 		 * @param asset:DisplayObject		 * @return DisplayObject		 */		protected function getModifiedAsset(asset : DisplayObject) : DisplayObject 		{			return asset;		}		/**		 * Make sure the listener is weak to prevent orphans.		 * 		 * @param type:String		 * @param listener:Function		 * @param useCapture:Boolean		 * @param priority:Boolean		 * @param useWeakReference:Boolean		 */		override public function addEventListener(type : String, listener : Function, useCapture : Boolean = false, priority : int = 0, useWeakReference : Boolean = true) : void		{			super.addEventListener(type, listener, useCapture, priority, useWeakReference);		}		/**		 * Dispose this asset.		 * Remove necessary listeners and remove it from loader queue.		 * 		 * @param event:Event		 */		private function dispose(event : Event) : void 		{			removeEventListener(Event.REMOVED_FROM_STAGE, dispose);			ImageQueue.removeEventListener(ImageLoaderEvent.COMPLETE, handleAssetLoaderEvents);			ImageQueue.removeEventListener(ImageLoaderEvent.PROGRESS, handleAssetLoaderEvents);			ImageQueue.removeEventListener(ImageLoaderEvent.ERROR, handleAssetLoaderEvents);			ImageQueue.imageLoader.removeAsset(this.name);		}		/**		 * ------------------------------------------------------		 * ------------   ANIMATIONS TO OVERRIDE   --------------		 * ------------------------------------------------------		 */		protected function animatePreloaderIn(preloader : DisplayObject, onComplete : Function) : void 		{			preloader.visible = true;			preloader.alpha = 1;						onComplete();		}		private function animatePreloaderInCompleted() : void 		{			if (_autoStart) loadAsset();		}
		protected function animatePreloaderOut(preloader : DisplayObject, onComplete : Function) : void 		{			preloader.visible = false;			preloader.alpha = 0;						onComplete();		}		private function animatePreloaderOutCompleted() : void 		{			animateAssetIn(_asset, function() : void {	});
		}
		protected function animateAssetIn(asset : DisplayObject, onComplete : Function) : void 		{			asset.visible = true;			asset.alpha = 1;						onComplete();		}	}}